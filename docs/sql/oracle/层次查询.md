---
tags:
  - sql/oracle
---


# 层次查询

*hierarchical_query_clause*::=

![层次查询子句语法](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/img/hierarchical_query_clause.gif)

*`condition`* 可以是[条件](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8)中描述的任何条件。

`START WITH` 指定层次结构的根行。

`CONNECT BY` 指定父行和子行之间的关系。

- `NOCYCLE` 参数指示 Oracle 数据库即使数据中存在 `CONNECT BY` 循环也返回行。将此参数与 `CONNECT_BY_ISCYCLE` 伪列一起使用,以查看包含循环的行。有关详细信息,请参阅 [[层次查询伪列#CONNECT_BY_ISCYCLE 伪列|CONNECT_BY_ISCYCLE 伪列]]。

- 在层次查询中,*`condition`* 中的一个表达式必须使用 `PRIOR` 运算符限定,以引用父行。例如:

  ```sql
  ... PRIOR expr = expr
  或
  ... expr = PRIOR expr
  ```

  如果 `CONNECT BY` *`condition`* 是复合的,则只需要一个条件需要 `PRIOR` 运算符,尽管可以有多个 `PRIOR` 条件。例如:

  ```sql
  CONNECT BY last_name != 'King' AND PRIOR employee_id = manager_id ...
  CONNECT BY PRIOR employee_id = manager_id and
             PRIOR account_mgr_id = customer_id ...
  ```

  `PRIOR` 是一元运算符,与一元 + 和 - 算术运算符具有相同的优先级。它对层次查询中当前行的父行求值紧跟其后的表达式。

  `PRIOR` 最常用于将列值与相等运算符进行比较。(`PRIOR` 关键字可以在运算符的任一侧。) `PRIOR` 会导致 Oracle 使用父行中的值。理论上,`CONNECT BY` 子句中的等号(=)以外的运算符也是可能的。但是,这些其他运算符创建的条件可能会导致组合的无限循环。在这种情况下,Oracle 会在运行时检测到循环并返回错误。

`CONNECT BY` 条件和 `PRIOR` 表达式都可以采用不相关子查询的形式。但是,`CURRVAL` 和 `NEXTVAL` 不是有效的 `PRIOR` 表达式,因此 `PRIOR` 表达式不能引用序列。

您还可以通过使用 `CONNECT_BY_ROOT` 运算符限定选择列表中的列来进一步优化层次查询。 这个运算符通过不仅返回直接父行,而且返回层次结构中的所有祖先行,扩展了层次查询的 `CONNECT BY [PRIOR]` 条件的功能。

参见:

[[层次查询运算符#CONNECT_BY_ROOT|CONNECT_BY_ROOT]] 了解有关此运算符的更多信息,以及"[[#层次查询示例]]"

Oracle按如下方式处理层次查询:

- 首先评估联接(如果存在),无论联接是在 `FROM` 子句中指定还是用 `WHERE` 子句谓词指定。
- 评估 `CONNECT BY` 条件。 
- 评估任何其余的 `WHERE` 子句谓词。

然后,Oracle使用这些评估的信息按以下步骤形成层次结构:

1. Oracle选择层次结构的根行,即满足 `START WITH` 条件的行。
2. Oracle选择每个根行的子行。每个子行必须满足与其中一个根行相关的 `CONNECT BY` 条件。
3. Oracle选择后代子行的后续代。Oracle首先选择步骤[2]中返回的行的子行,然后是这些子行的子行,依此类推。Oracle始终通过评估与当前父行相关的 `CONNECT BY` 条件来选择子行。
4. 如果查询包含没有联接的 `WHERE` 子句,则 Oracle 从层次结构中删除不满足 `WHERE` 子句条件的所有行。Oracle对每行单独评估此条件,而不是删除不满足条件的行的所有子行。
5. Oracle以[图9-1](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__I2066595)所示的顺序返回行。在图中,子项出现在其父项下方。有关层次树的解释,请参见[图3-1](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Hierarchical-Query-Pseudocolumns.html#GUID-D91FFF59-ECB0-40F0-AB4C-7A9D27EBEEF1__I1009270)。

图 9-1 层次查询

![层次查询](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/img/sqlrf002.gif)

要查找父行的子行,Oracle会对父行的 `PRIOR` 表达式进行求值,并对表中的每一行求值 `CONNECT BY` 条件中的其他表达式。条件为真的行是父行的子行。`CONNECT BY` 条件可以包含其他条件来进一步过滤查询选择的行。

如果 `CONNECT BY` 条件导致层次结构中的循环,则 Oracle 返回错误。如果一行既是另一行的父行(或祖父行或直接祖先)也是其子行(或孙行或直接后代),则会发生循环。

> [!note] 在层次查询中,不要指定 `ORDER BY` 或 `GROUP BY`,因为它们会覆盖 `CONNECT BY` 结果的层次顺序。如果要对具有相同父级的同级行进行排序,请使用 `ORDER SIBLINGS BY` 子句。参见*order_by_clause*。

*order_by_clause*::=
![order by](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/img/order_by_clause.gif)

### 层次查询示例

CONNECT BY 示例

以下层次查询使用 `CONNECT BY` 子句定义员工和管理者之间的关系:

```sql
SELECT employee_id, last_name, manager_id
  FROM employees
  CONNECT BY PRIOR employee_id = manager_id;
  
EMPLOYEE_ID LAST_NAME                 MANAGER_ID
----------- ------------------------- ----------
        101 Kochhar                          100
        108 Greenberg                        101
        109 Faviet                           108
        110 Chen                             108
        111 Sciarra                          108
        112 Urman                            108
        113 Popp                             108
        200 Whalen                           101
        203 Mavris                           101
        204 Baer                             101
. . .
```

### LEVEL 示例 

下一个示例与前面的示例类似,但使用 `LEVEL` 伪列显示父行和子行:

```sql  
SELECT employee_id, last_name, manager_id, LEVEL
  FROM employees
  CONNECT BY PRIOR employee_id = manager_id;
  
EMPLOYEE_ID LAST_NAME                 MANAGER_ID      LEVEL
----------- ------------------------- ---------- ----------
        101 Kochhar                          100          1
        108 Greenberg                        101          2
        109 Faviet                           108          3
        110 Chen                             108          3
        111 Sciarra                          108          3
        112 Urman                            108          3
        113 Popp                             108          3
        200 Whalen                           101          2
        203 Mavris                           101          2
        204 Baer                             101          2
        205 Higgins                          101          2
        206 Gietz                            205          3
        102 De Haan                          100          1
```

### START WITH 示例

下一个示例添加 `START WITH` 子句以指定层次结构的根行,并使用 `SIBLINGS` 关键字的 `ORDER BY` 子句在层次结构内保留排序:

```sql
SELECT last_name, employee_id, manager_id, LEVEL
  FROM employees
  START WITH employee_id = 100
  CONNECT BY PRIOR employee_id = manager_id
  ORDER SIBLINGS BY last_name;
  
LAST_NAME                 EMPLOYEE_ID MANAGER_ID      LEVEL
------------------------- ----------- ---------- ----------
King                              100                     1
Cambrault                         148        100          2
Bates                             172        148          3
Bloom                             169        148          3
Fox                               170        148          3
Kumar                             173        148          3
Ozer                              168        148          3
Smith                             171        148          3
De Haan                           102        100          2
Hunold                            103        102          3
Austin                            105        103          4
Ernst                             104        103          4
Lorentz                           107        103          4
Pataballa                         106        103          4
Errazuriz                         147        100          2
Ande                              166        147          3
Banda                             167        147          3
```

在 `hr.employees` 表中,员工 Steven King 是公司的负责人,没有经理。他的员工中有 John Russell,Russell 是部门 80 的经理。如果将 Russell 设置为 King 的经理更新 `employees` 表,将在数据中创建一个循环:

```sql
UPDATE employees SET manager_id = 145
  WHERE employee_id = 100;

SELECT last_name "Employee",
   LEVEL, SYS_CONNECT_BY_PATH(last_name, '/') "Path"
  FROM employees
  WHERE level <= 3 AND department_id = 80
  START WITH last_name = 'King' 
  CONNECT BY PRIOR employee_id = manager_id AND LEVEL <= 4; 
  
ERROR:
ORA-01436: CONNECT BY loop in user data
```

`CONNECT BY` 条件中的 `NOCYCLE` 参数会导致 Oracle 尽管循环仍返回行。`CONNECT_BY_ISCYCLE` 伪列向您显示哪些行包含循环:

```sql
SELECT last_name "Employee", CONNECT_BY_ISCYCLE "Cycle",
  LEVEL, SYS_CONNECT_BY_PATH(last_name, '/') "Path"
  FROM employees
  WHERE level <= 3 AND department_id = 80
  START WITH last_name = 'King'
  CONNECT BY NOCYCLE PRIOR employee_id = manager_id AND LEVEL <= 4
  ORDER BY "Employee", "Cycle", LEVEL, "Path";
  

Employee                       Cycle      LEVEL Path
------------------------- ---------- ---------- -------------------------
Abel                               0          3 /King/Zlotkey/Abel
Ande                               0          3 /King/Errazuriz/Ande
Banda                              0          3 /King/Errazuriz/Banda
Bates                              0          3 /King/Cambrault/Bates
Bernstein                          0          3 /King/Russell/Bernstein
Bloom                              0          3 /King/Cambrault/Bloom
Cambrault                          0          2 /King/Cambrault
Cambrault                          0          3 /King/Russell/Cambrault
Doran                              0          3 /King/Partners/Doran
Errazuriz                          0          2 /King/Errazuriz
Fox                                0          3 /King/Cambrault/Fox
...
```

### CONNECT_BY_ISLEAF 示例

以下语句显示如何使用层次查询将列的值转换为逗号分隔列表:

```sql
SELECT LTRIM(SYS_CONNECT_BY_PATH (warehouse_id,','),',') FROM
  (SELECT ROWNUM r, warehouse_id FROM warehouses)
  WHERE CONNECT_BY_ISLEAF = 1
  START WITH r = 1
  CONNECT BY r = PRIOR r + 1
  ORDER BY warehouse_id;
  
LTRIM(SYS_CONNECT_BY_PATH(WAREHOUSE_ID,','),',')
--------------------------------------------------------------------------------
1,2,3,4,5,6,7,8,9
```

### CONNECT_BY_ROOT 示例

以下示例返回部门 110 中每个员工的姓、该员工在层次结构中高于其的最高级经理的姓、经理和员工之间的级别数,以及它们之间的路径:

```sql 
SELECT last_name "Employee", CONNECT_BY_ROOT last_name "Manager",
  LEVEL-1 "Pathlen", SYS_CONNECT_BY_PATH(last_name, '/') "Path"
  FROM employees
  WHERE LEVEL > 1 and department_id = 110
  CONNECT BY PRIOR employee_id = manager_id
  ORDER BY "Employee", "Manager", "Pathlen", "Path";
  
Employee        Manager            Pathlen Path
--------------- --------------- ---------- ------------------------------
Gietz           Higgins                  1 /Higgins/Gietz
Gietz           King                     3 /King/Kochhar/Higgins/Gietz
Gietz           Kochhar                  2 /Kochhar/Higgins/Gietz
Higgins         King                     2 /King/Kochhar/Higgins
Higgins         Kochhar                  1 /Kochhar/Higgins
```

以下示例使用 `GROUP BY` 子句返回部门 110 中每个员工及层次结构中高于该员工的所有员工的总薪水:

```sql
SELECT name, SUM(salary) "Total_Salary" FROM (
  SELECT CONNECT_BY_ROOT last_name as name, Salary 
    FROM employees
    WHERE department_id = 110
    CONNECT BY PRIOR employee_id = manager_id)
    GROUP BY name
  ORDER BY name, "Total_Salary";
  
NAME                      Total_Salary
------------------------- ------------
Gietz                             8300
Higgins                          20300
King                             20300
Kochhar                          20300
```

参见:

- [[层次查询伪列#LEVEL 伪列|LEVEL 伪列]] 和 [[层次查询伪列#CONNECT_BY_ISCYCLE 伪列|CONNECT_BY_ISCYCLE 伪列]] 关于这些伪列在层次查询中的操作讨论
- [[SYS_CONNECT_BY_PATH]] 获取从根到节点的列值路径的信息
- *[order_by_clause](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/img/order_by_clause.gif)* 了解 `ORDER BY` 子句中 `SIBLINGS` 关键字的更多信息
- *[subquery_factoring_clause](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2077142)*,它支持递归子查询重写(递归 WITH)并允许查询层次数据。 与 `CONNECT BY` 相比,此功能更强大,因为它提供了深度优先搜索和广度优先搜索,并支持多个递归分支。